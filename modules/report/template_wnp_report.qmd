---
title: param_analysis_name analysis report
date: today
bibliography: _template/references.bib
csl: _template/vancouver_superscript.csl
knitr:
  opts_chunk:
    echo: false
    message: false
    warning: false
format:
    html:
        grid:
            body-width: 1200px
            margin-width: 20px
        theme: _template/litera_edited.scss
        embed-resources: true
        fig-width: 10
        fig-height: 5
        fig-dpi: 200
        toc: true
        toc-location: left
        toc-depth: 4
        toc-expand: 2
        include-in-header:
            - text: <link rel="preconnect" href="https://fonts.googleapis.com"> <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> <link href="https://fonts.googleapis.com/css2?family=Atkinson+Hyperlegible:ital,wght@0,700;1,700&family=Poppins:ital,wght@0,400;0,600;1,400;1,600&display=swap" rel="stylesheet">
params:
  analysis_name: param_analysis_name
  panning_id: param_panning_id
---

## Introduction

This is the WNP report for `r params$analysis_name`. The report is interactive: click around on the plots and use the download buttons to export the tables/sequences for further analysis!

Want to know more about how the results were generated? Check the bottom of the report ðŸ‘‡

```{r}
# we have to source the pre render script every time which is annoying
source("_template/pre_render_script.R")
source("_template/panning_pre_render.R")
metadata <- filter(metadata, report_id == params$analysis_name)
all_counts_filtered <- filter(all_counts_filtered, report_id == params$analysis_name)
```

## Top 100 most abundant sequences in each round

The trees in this section visualise the 100 most abundant **clones** in each round. Abundance is measured in counts per million (CPM) and so can be compared between rounds.

```{r}
#| echo: false
#| message: false
#| warning: false

render_child <- function(i) {
  res = knitr::knit_child(
   text = xfun::read_utf8("./_template/_abundance_tree.qmd"),
   envir = rlang::env(this_round = i, name = paste0("Round ", i)),
   quiet = TRUE
  )
  cat(res, sep = '\n')
  cat("\n")
}
```

```{r}
#| results: "asis"
#| echo: false
purrr::walk(unique(metadata$round), render_child)
```

## Enriched clusters

### PCA plot & top 100s

```{r}
# get enriched sequences
# get enriched sequences
enriched_clustered <- determine_enriched(
    all_counts_filtered, as.numeric(params$panning_id), logfc_cutoff = 1.5, max_round = max(metadata$round))

# create the pca plot & find top 100
cluster_pca_plot_data <- make_cluster_pca_data(enriched_clustered, as.numeric(params$panning_id), metadata, max_round = max(metadata$round))
plot_cluster_pca(cluster_pca_plot_data$pca_data, cluster_pca_plot_data$table_data, params$analysis_name)

# write to file so they can be downloaded
diversity_100 <- cluster_pca_plot_data$table_data %>%
    filter(cluster_lead %in% cluster_pca_plot_data$top_100_diversity) %>%
    select(cluster_lead, trimmed_nt_sequence)
top_100_diversity_nt_seq <- Biostrings::DNAStringSet(diversity_100$trimmed_nt_sequence)
names(top_100_diversity_nt_seq) <- diversity_100$cluster_lead

Biostrings::writeXStringSet(
    top_100_diversity_nt_seq,
    file = paste0(
        str_replace_all(params$analysis_name, " ", "_"),
        "_top_100_diversity_nt_seq.fasta"))

enrichment_100 <- cluster_pca_plot_data$table_data %>%
    filter(cluster_lead %in% cluster_pca_plot_data$top_100_enrichment) %>%
    select(cluster_lead, trimmed_nt_sequence)
top_100_enrichment_nt_seq <- Biostrings::DNAStringSet(enrichment_100$trimmed_nt_sequence)
names(top_100_enrichment_nt_seq) <- enrichment_100$cluster_lead

Biostrings::writeXStringSet(
    top_100_enrichment_nt_seq,
    file = paste0(
        str_replace_all(params$analysis_name, " ", "_"),
        "_top_100_enrichment_nt_seq.fasta"))
```

{{< downloadthis r paste0(str_replace_all(params$analysis_name, " ", "_"), "_top_100_enrichment_nt_seq.fasta") dname=r paste0(str_replace_all(params$analysis_name, " ", "_"), "_top_100_enrichment_nt_seq") label="Download top 100 (by enrichment) FASTA" icon=file-earmark-arrow-down type=secondary class=data-button id=top100_enrichment >}}

{{< downloadthis r paste0(str_replace_all(params$analysis_name, " ", "_"), "_top_100_diversity_nt_seq.fasta") dname=r paste0(str_replace_all(params$analysis_name, " ", "_"), "_top_100_diversity_nt_seq") label="Download top 100 (by diversity) FASTA" icon=file-earmark-arrow-down type=secondary class=data-button id=top100_diversity >}}

### Tree of the top 100 most enriched clusters

```{r}
#| echo: false
#| message: false
#| warning: false

# use suppressMessages to stop the stupid using gonnet message
enriched_tree_data <- suppressMessages(make_interactive_tree_data(
    enriched_clustered, which_round = max(metadata$round),
    id = as.numeric(params$panning_id), enriched = TRUE))

enriched_tree <- plot_interactive_tree(
    enriched_tree_data$tree_data,
    enriched_tree_data$table_data,
    name = params$analysis_name,
    enriched = TRUE)

```

```{r}
#| fig-width: 10
#| fig-height: 1
enriched_tree$legend
```

```{r}
enriched_tree$interactive_plot
```

## Analysis method

Raw sequencing reads are first trimmed (to remove sequencing adapters) and merged (as two paired reads are required to cover the entire nanobody sequence) using the software [TrimGalore](https://github.com/FelixKrueger/TrimGalore) and [FLASH](https://ccb.jhu.edu/software/FLASH/), respectively. Then, quality control of the run is performed with [multiQC](https://github.com/MultiQC/MultiQC). To identify the important parts of the nanobody sequence (for example the germline genes and CDRs), [IgBLAST](https://ncbi.github.io/igblast/) is used with a custom alpaca reference (created using VDJ sequences deposited in the [IMGT database](https://www.imgt.org/vquest/refseqh.html)).

Before analysis, reads that likely represent sequencing errors: those containing frameshifts, stop codons or having very low counts per million (CPM) are removed. Filtered nanobody sequences are then tracked through the panning process to determine their enrichment (measured as log2 fold change from Round 0, before panning to the end of the panning process, usually Round 2). Enriched nanobodies are then clustered in order to remove redundancy, and if there are a large number of clusters, a top 100 is chosen.

```{mermaid}
%%{
  init: {
    'theme': 'base',
    'themeVariables': {
      'primaryColor': '#fbf0ed',
      'primaryTextColor': '#e83e8c',
      'primaryBorderColor': '#e83e8c',
      'lineColor': '#FF784F',
      'secondaryColor': '#006100',
      'tertiaryColor': '#fff'
    }
  }
}%%

flowchart TD
import["Raw sequencing read pairs"] --> trim_merge["Trim and merge raw reads"]
trim_merge --> seqQC["Quality control of sequencing run"]
seqQC --> annotate["Annotate nanobody germline genes, CDRs"]
annotate --> filtering["Filter to remove sequencing errors"]
filtering --> enrichment["Determine enrichment (log2 fold change) across panning rounds"]
enrichment --> clustering["Group similar nanobodies into clusters"]
clustering --> top_100["If required, narrow enriched clusters down to a top 100"]
```